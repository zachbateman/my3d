<!DOCTYPE html>

<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>My3D Environment</title>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="/static/three.min.js"></script>
        <script src="/static/OrbitControls.js"></script>
    </head>

    <body style="margin: 0;">
        <div id="space" z-index=-1 style="width: 100%; height: 100vh; min-height: 600px; margin: 0 auto; text-align: center;"></div>
    </body>

    <script type="text/javascript">
        var container = document.getElementById("space");
        var camera, scene, renderer;
        var scale = 1.0;
        var radius = 2;
        var blue = 0x2277cc;
        var green = 0x22cc77;
        var red = 0x772211;

        var objects = [];  // for containing all the 3D user-generated objects

        // Working on Raycasting/Interaction...
        // https://github.com/mrdoob/three.js/blob/master/examples/webgl_instancing_raycast.html

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(1, 1);


        function init() {
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(80, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.up.set(0, 0, 1);
            camera.position.set(0, -30, 12);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.15;
            controls.autoRotate = true;
            controls.autoRotateSpeed = -0.5;
            container.addEventListener('mousedown', function () {controls.autoRotate=false});  // stop rotation when user clicks

            scene = new THREE.Scene();

            light = new THREE.DirectionalLight(0xFFFFFF, 1);
            light.position.set(0, 10, 0);
            light.target.position.set(-5, 0, 0);
            scene.add(light);
            scene.add(light.target);

            wirefloor = new THREE.Mesh(
                new THREE.PlaneGeometry(300, 300, 100, 100),
                new THREE.MeshBasicMaterial({color: 0x334455, wireframe: true, opacity: 0.25, transparent: true})
            );
            wirefloor.name = 'wirefloor';
            scene.add(wirefloor);

            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            {% for point in world.points %}
                add_point({{ point.point }}, {{ point.color }}, {{ point.alpha }});
            {% endfor %}

            {% for line in world.lines %}
                add_line({{ line.point1 }}, {{ line.point2 }}, '{{ line.color }}')
            {% endfor %}

            {% for pane in world.text_panes %}
                tpane = add_textpane({{ pane.text_lines | safe }}, {{ pane.center_point }}, {{ pane.width }}, {{ pane.height }}, {{ pane.rotation }});
                {% if pane.mouseover_effects %}
                    tpane.mouseover_color = {{ pane.mouseover_effects[0] }};
                {% endif %}
            {% endfor %}

            {% for pipe in world.pipes %}
                add_pipe({{ pipe.points }}, 'blue', {{ pipe.radius }}, {{ pipe.segments }});
            {% endfor %}

            {% for sphere in world.spheres %}
                add_sphere({{ sphere.location }}, {{ sphere.radius }});
            {% endfor %}



            // Add scattered background points
            const vertices = [];
            for (let i = 0; i < 500; i ++) {
                const x = THREE.MathUtils.randFloatSpread(300);
                const y = THREE.MathUtils.randFloatSpread(300);
                const z = THREE.MathUtils.randFloatSpread(300);
                vertices.push(x, y, z);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({size: 0.5, opacity: 0.4, transparent: true, color: 0x333333});
            const points = new THREE.Points(geometry, material);
            points.name = 'floating_points';
            scene.add(points);
        };


        function animate() {
            requestAnimationFrame(animate);
            render();
        };

        function render() {
            raycaster.setFromCamera(mouse, camera);

            for (i=0; i < objects.length; i++) {
                objects[i].intersected = false;
            }

            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0 && intersects[0].object.name != 'wirefloor' && intersects[0].object.name != 'floating_points') {
                intersects[0].object.intersected = true;
                if ('mouseover_color' in intersects[0].object) {
                    intersects[0].object.material.color.set(intersects[0].object.mouseover_color);
                } else {
                    intersects[0].object.material.color.set(red);
                }
            }

            for (i=0; i < objects.length; i++) {
                if (!objects[i].intersected) {
                    objects[i].material.color.set(objects[i].origColor);
                }
            }

            renderer.render(scene, camera);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }


        function add_point(point, color, alpha) {
            console.log(point);
            var geometry = new THREE.BufferGeometry();
            //geometry.setAttribute('position', point);
            //var material = new THREE.PointsMaterial({color: color});
            //point = new THREE.Points(geometry, material);
           // scene.add(point);
            //objects.push(point);
        };

        function add_pipe(points, color, radius, segments) {
            var curve_vectors = [];
            for (var i=0; i < points.length; i++) {
                curve_vectors.push(new THREE.Vector3(points[i][0], points[i][1], points[i][2]).multiplyScalar(scale));
            }
            curve = new THREE.CatmullRomCurve3(curve_vectors);
            var radialSegments = Math.floor(8 + 5.2 * Math.log(radius));
            pipe = new THREE.Mesh(
                new THREE.TubeGeometry(curve, segments, radius, radialSegments, false),
                new THREE.MeshBasicMaterial({color: blue, wireframe: true})
            );
            pipe.origColor = pipe.material.color.getHex();
            scene.add(pipe);
            objects.push(pipe);
        };

        function add_line(point_1, point_2, color) {
            var points = [
                new THREE.Vector3(point_1[0], point_1[1], point_1[2]).multiplyScalar(scale),
                new THREE.Vector3(point_2[0], point_2[1], point_2[2]).multiplyScalar(scale),
            ];
            var line = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({color: color}),
            );
            line.origColor = line.material.color.getHex();
            scene.add(line);
            objects.push(line);
        }

        function add_textpane(text_lines, center_point, width, height, rotation) {
            var canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;

            ctx.fillStyle = '#66bb8822';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#66ffbbbb';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#88ffddff';
            ctx.font = '30px Arial';
            for (var i=0; i < text_lines.length; i++) {
                ctx.fillText(text_lines[i], 20, 40*(i+1));
            }

            var texture = new THREE.CanvasTexture(canvas);
            var material_text = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
            });
            var textPane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height, 1, 1),
                material_text
            );
            textPane.rotation.x = Math.PI / 2;
            textPane.rotation.y = rotation;
            textPane.position.set(center_point[0], center_point[1], center_point[2]);
            textPane.origColor = textPane.material.color.getHex();
            scene.add(textPane);
            objects.push(textPane);
            return textPane;
        }

        function add_sphere(location, radius) {
            var segments = Math.floor(8 + 5 * Math.log(radius));
            var sphere = new THREE.Mesh(
                new THREE.SphereGeometry(radius, segments, segments),
                new THREE.MeshBasicMaterial({color: blue, wireframe: true}),
            );
            sphere.position.set(location[0], location[1], location[2]);
            sphere.origColor = sphere.material.color.getHex();
            scene.add(sphere);
            objects.push(sphere);
        }

        window.addEventListener('mousemove', onMouseMove, false);
        init();
        animate();
    </script>

</html>
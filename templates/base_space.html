<!DOCTYPE html>

<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>My3D Environment</title>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="/static/three.min.js"></script>
        <script src="/static/OrbitControls.js"></script>
    </head>

    <body style="margin: 0;">
        <div id="space" z-index=-1 style="width: 100%; height: 100vh; min-height: 600px; margin: 0 auto; text-align: center;"></div>
    </body>

    <script type="text/javascript">
        var container = document.getElementById("space");
        var camera, scene, renderer;
        var scale = 1.0;
        var radius = 2;
        var blue = 0x2277cc;
        var green = 0x22cc77;
        var red = 0x772211;

        var objects = [];  // for containing all the 3D user-generated objects

        // Working on Raycasting/Interaction...
        // https://github.com/mrdoob/three.js/blob/master/examples/webgl_instancing_raycast.html

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(1, 1);


        function init() {
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(80, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.up.set(0, 0, 1);
            camera.position.set(0, -30, 12);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.15;
            controls.autoRotate = true;
            controls.autoRotateSpeed = -0.5;
            container.addEventListener('mousedown', function () {controls.autoRotate=false});  // stop rotation when user clicks

            scene = new THREE.Scene();

            light = new THREE.DirectionalLight(0xFFFFFF, 1);
            light.position.set(0, 10, 0);
            light.target.position.set(-5, 0, 0);
            scene.add(light);
            scene.add(light.target);

            wirefloor = new THREE.Mesh(
                new THREE.PlaneGeometry(300, 300, 100, 100),
                new THREE.MeshBasicMaterial({color: 0x334455, wireframe: true, opacity: 0.25, transparent: true})
            );
            wirefloor.name = 'wirefloor';
            scene.add(wirefloor);

            axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            {% for pipe in world.pipes %}
                add_pipe({{ pipe.points }}, 'blue', {{ pipe.radius }}, {{ pipe.segments }});
            {% endfor %}

            {% for line in world.lines %}
                add_line({{ line.point1 }}, {{ line.point2 }}, '{{ line.color }}')
            {% endfor %}

            {% for sphere in world.spheres %}
                add_sphere({{ sphere.location }}, {{ sphere.radius }});
            {% endfor %}
        };

        function animate() {
            requestAnimationFrame(animate);
            render();
        };

        function render() {
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0 && intersects[0].object.name != 'wirefloor') {
                intersects[0].object.material.color.set(red);
            }

            renderer.render(scene, camera);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }


        function add_pipe(points, color, radius, segments) {
            var curve_vectors = [];
            for (var i=0; i < points.length; i++) {
                curve_vectors.push(new THREE.Vector3(points[i][0], points[i][1], points[i][2]).multiplyScalar(scale));
            }
            curve = new THREE.CatmullRomCurve3(curve_vectors);
            var radialSegments = Math.floor(8 + 5.2 * Math.log(radius));
            pipe = new THREE.Mesh(
                new THREE.TubeGeometry(curve, segments, radius, radialSegments, false),
                new THREE.MeshBasicMaterial({color: blue, wireframe: true})
            );
            scene.add(pipe);
            objects.push(pipe);
        };

        function add_line(point_1, point_2, color) {
            var points = [
                new THREE.Vector3(point_1[0], point_1[1], point_1[2]).multiplyScalar(scale),
                new THREE.Vector3(point_2[0], point_2[1], point_2[2]).multiplyScalar(scale),
            ];
            var line = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({color: color}),
            );
            scene.add(line);
            objects.push(line);
        }

        function add_sphere(location, radius) {
            var segments = Math.floor(8 + 5 * Math.log(radius));
            var sphere = new THREE.Mesh(
                new THREE.SphereGeometry(radius, segments, segments),
                new THREE.MeshBasicMaterial({color: blue, wireframe: true}),
            );
            sphere.position.set(location[0], location[1], location[2]);
            scene.add(sphere);
            objects.push(sphere);
        }

        window.addEventListener('mousemove', onMouseMove, false);
        init();
        animate();
    </script>

</html>